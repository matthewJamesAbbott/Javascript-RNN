<!--
Matthew Abbott 2025

RNN
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Advanced RNN Trainer</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 2rem; }
        .section { margin-bottom: 2rem; border-bottom: 1px solid #ccc; padding-bottom: 1rem; }
        label { display: block; margin-top: 0.5rem; }
        .results { background-color: #f5f5f5; padding: 1rem; margin: 1rem 0; border-radius: 5px; }
        .metric { margin: 0.5rem 0; font-weight: bold; }
        table { border-collapse: collapse; width: 100%; margin: 1rem 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .loss-chart { width: 100%; height: 200px; background: #fafafa; border: 1px solid #ddd; margin: 1rem 0; }
        select, input { padding: 4px; margin: 2px; }
        .inline { display: inline-block; margin-right: 1rem; }
    </style>
</head>
<body>
    <h1>Advanced RNN Trainer</h1>

    <div class="section">
        <h2>Network Configuration</h2>
        <div class="inline">
            <label>Input Size: <input type="number" id="inputSize" value="4" min="1"></label>
        </div>
        <div class="inline">
            <label>Hidden Sizes (comma sep): <input type="text" id="hiddenSizes" value="16"></label>
        </div>
        <div class="inline">
            <label>Output Size: <input type="number" id="outputSize" value="3" min="1"></label>
        </div>
        <div class="inline">
            <label>Learning Rate: <input type="number" id="learningRate" value="0.01" step="0.001" min="0.0001" max="1"></label>
        </div>
        <div class="inline">
            <label>Cell Type:
                <select id="cellType">
                    <option value="rnn">Simple RNN</option>
                    <option value="lstm" selected>LSTM</option>
                    <option value="gru">GRU</option>
                </select>
            </label>
        </div>
        <div class="inline">
            <label>Activation:
                <select id="activation">
                    <option value="sigmoid">Sigmoid</option>
                    <option value="tanh" selected>Tanh</option>
                    <option value="relu">ReLU</option>
                </select>
            </label>
        </div>
        <div class="inline">
            <label>Output Activation:
                <select id="outputActivation">
                    <option value="sigmoid">Sigmoid</option>
                    <option value="tanh">Tanh</option>
                    <option value="softmax">Softmax</option>
                    <option value="linear" selected>Linear</option>
                </select>
            </label>
        </div>
        <div class="inline">
            <label>Loss Function:
                <select id="lossFunction">
                    <option value="mse" selected>MSE</option>
                    <option value="crossentropy">Cross-Entropy</option>
                </select>
            </label>
        </div>
        <div class="inline">
            <label>Gradient Clip: <input type="number" id="gradientClip" value="5.0" step="0.5" min="0.1"></label>
        </div>
        <div class="inline">
            <label>BPTT Steps (0=full): <input type="number" id="bpttSteps" value="0" min="0"></label>
        </div>
        <br><br>
        <button onclick="createNetwork()">Create Network</button>
        <span id="networkStatus" style="margin-left:1rem;"></span>
    </div>

    <div class="section">
        <h2>Load Training Data</h2>
        <input type="file" id="csvFile" accept=".csv">
        <button onclick="loadCSV()">Load CSV File</button>
        <span id="dataStatus"></span><br>
        <label>Or paste CSV data (input cols, then target cols per row):</label>
        <textarea id="csvPaste" rows="5" cols="60"></textarea>
        <button onclick="loadCSVText()">Load Pasted CSV</button>
    </div>

    <div class="section">
        <h2>Save/Load Network</h2>
        <button onclick="saveNetwork()">Save Network (.json)</button>
        <button onclick="loadNetwork()">Load Network (.json)</button>
        <input type="file" id="modelFile" accept=".json" style="display:none;">
        <span id="modelStatus"></span>
    </div>

    <div class="section">
        <h2>Train Network</h2>
        <div class="inline">
            <label>Epochs: <input type="number" id="epochs" value="100" min="1" max="100000"></label>
        </div>
        <div class="inline">
            <label>Batch Size: <input type="number" id="batchSize" value="1" min="1"></label>
        </div>
        <div class="inline">
            <label>Validation Split: <input type="number" id="validationSplit" value="0.2" step="0.05" min="0" max="0.5"></label>
        </div>
        <div class="inline">
            <label>Log Every N Epochs: <input type="number" id="logInterval" value="10" min="1"></label>
        </div>
        <br><br>
        <button onclick="trainNetwork()">Train RNN</button>
        <button onclick="stopTraining()">Stop</button>
        <span id="trainStatus"></span>
        <div id="lossLog" class="results" style="max-height:300px; overflow-y:auto;"></div>
        <canvas id="lossChart" class="loss-chart"></canvas>
    </div>

    <div class="section">
        <h2>Predict</h2>
        <label>Input Sequence (rows separated by ; or newline, values by comma):<br>
        <textarea id="predictSeq" rows="3" cols="40"></textarea></label><br>
        <button onclick="predictSequence()">Predict Sequence</button>
        <div id="predictOutput"></div>
    </div>

    <script>
    "use strict";

    // ========== Activation Functions ==========
    const Activations = {
        sigmoid: {
            fn: x => 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x)))),
            dfn: y => y * (1 - y)
        },
        tanh: {
            fn: x => Math.tanh(x),
            dfn: y => 1 - y * y
        },
        relu: {
            fn: x => Math.max(0, x),
            dfn: y => y > 0 ? 1 : 0
        },
        linear: {
            fn: x => x,
            dfn: y => 1
        },
        softmax: {
            fn: (x, arr) => {
                const maxVal = Math.max(...arr);
                const exps = arr.map(v => Math.exp(v - maxVal));
                const sum = exps.reduce((a, b) => a + b, 0);
                return exps[arr.indexOf(x)] / sum;
            },
            dfn: y => y * (1 - y)
        }
    };

    function applySoftmax(arr) {
        const maxVal = Math.max(...arr);
        const exps = arr.map(v => Math.exp(v - maxVal));
        const sum = exps.reduce((a, b) => a + b, 0);
        return exps.map(e => e / sum);
    }

    // ========== Loss Functions ==========
    const LossFunctions = {
        mse: {
            loss: (pred, target) => {
                let sum = 0;
                for (let i = 0; i < pred.length; i++) {
                    sum += Math.pow(pred[i] - target[i], 2);
                }
                return sum / pred.length;
            },
            gradient: (pred, target) => pred.map((p, i) => p - target[i])
        },
        crossentropy: {
            loss: (pred, target) => {
                let sum = 0;
                for (let i = 0; i < pred.length; i++) {
                    const p = Math.max(1e-15, Math.min(1 - 1e-15, pred[i]));
                    sum -= target[i] * Math.log(p) + (1 - target[i]) * Math.log(1 - p);
                }
                return sum / pred.length;
            },
            gradient: (pred, target) => pred.map((p, i) => {
                const pClip = Math.max(1e-15, Math.min(1 - 1e-15, p));
                return (pClip - target[i]) / (pClip * (1 - pClip) + 1e-15);
            })
        }
    };

    // ========== Gradient Clipping ==========
    function clipGradient(grad, maxNorm) {
        if (Array.isArray(grad)) {
            return grad.map(g => clipGradient(g, maxNorm));
        }
        return Math.max(-maxNorm, Math.min(maxNorm, grad));
    }

    // ========== Simple RNN Cell ==========
    class SimpleRNNCell {
        constructor(inputSize, hiddenSize, activation) {
            this.inputSize = inputSize;
            this.hiddenSize = hiddenSize;
            this.activation = activation;
            
            const scale = Math.sqrt(2.0 / (inputSize + hiddenSize));
            this.Wih = this.randomMatrix(hiddenSize, inputSize, scale);
            this.Whh = this.randomMatrix(hiddenSize, hiddenSize, scale);
            this.bh = new Array(hiddenSize).fill(0);
            
            this.dWih = this.zeroMatrix(hiddenSize, inputSize);
            this.dWhh = this.zeroMatrix(hiddenSize, hiddenSize);
            this.dbh = new Array(hiddenSize).fill(0);
        }

        randomMatrix(rows, cols, scale) {
            return Array.from({length: rows}, () => 
                Array.from({length: cols}, () => (Math.random() - 0.5) * 2 * scale)
            );
        }

        zeroMatrix(rows, cols) {
            return Array.from({length: rows}, () => new Array(cols).fill(0));
        }

        forward(input, prevH) {
            const act = Activations[this.activation];
            const h = new Array(this.hiddenSize);
            const preH = new Array(this.hiddenSize);
            
            for (let i = 0; i < this.hiddenSize; i++) {
                let sum = this.bh[i];
                for (let j = 0; j < this.inputSize; j++) sum += this.Wih[i][j] * input[j];
                for (let j = 0; j < this.hiddenSize; j++) sum += this.Whh[i][j] * prevH[j];
                preH[i] = sum;
                h[i] = act.fn(sum);
            }
            return { h, preH, prevH: prevH.slice(), input: input.slice() };
        }

        backward(dh, cache, clipVal) {
            const act = Activations[this.activation];
            const { h, preH, prevH, input } = cache;
            
            const dhRaw = new Array(this.hiddenSize);
            for (let i = 0; i < this.hiddenSize; i++) {
                dhRaw[i] = clipGradient(dh[i] * act.dfn(h ? h[i] : Activations[this.activation].fn(preH[i])), clipVal);
            }

            const dInput = new Array(this.inputSize).fill(0);
            const dPrevH = new Array(this.hiddenSize).fill(0);

            for (let i = 0; i < this.hiddenSize; i++) {
                for (let j = 0; j < this.inputSize; j++) {
                    this.dWih[i][j] += dhRaw[i] * input[j];
                    dInput[j] += this.Wih[i][j] * dhRaw[i];
                }
                for (let j = 0; j < this.hiddenSize; j++) {
                    this.dWhh[i][j] += dhRaw[i] * prevH[j];
                    dPrevH[j] += this.Whh[i][j] * dhRaw[i];
                }
                this.dbh[i] += dhRaw[i];
            }
            return { dInput, dPrevH };
        }

        applyGradients(lr, clipVal) {
            for (let i = 0; i < this.hiddenSize; i++) {
                for (let j = 0; j < this.inputSize; j++) {
                    this.Wih[i][j] -= lr * clipGradient(this.dWih[i][j], clipVal);
                    this.dWih[i][j] = 0;
                }
                for (let j = 0; j < this.hiddenSize; j++) {
                    this.Whh[i][j] -= lr * clipGradient(this.dWhh[i][j], clipVal);
                    this.dWhh[i][j] = 0;
                }
                this.bh[i] -= lr * clipGradient(this.dbh[i], clipVal);
                this.dbh[i] = 0;
            }
        }

        resetGradients() {
            this.dWih = this.zeroMatrix(this.hiddenSize, this.inputSize);
            this.dWhh = this.zeroMatrix(this.hiddenSize, this.hiddenSize);
            this.dbh = new Array(this.hiddenSize).fill(0);
        }

        getHiddenSize() { return this.hiddenSize; }

        toJSON() {
            return { type: 'rnn', inputSize: this.inputSize, hiddenSize: this.hiddenSize,
                     activation: this.activation, Wih: this.Wih, Whh: this.Whh, bh: this.bh };
        }

        static fromJSON(json) {
            const cell = new SimpleRNNCell(json.inputSize || 1, json.hiddenSize || 1, json.activation || 'tanh');
            if (json.Wih) cell.Wih = json.Wih;
            if (json.Whh) cell.Whh = json.Whh;
            if (json.bh) cell.bh = json.bh;
            return cell;
        }
    }

    // ========== LSTM Cell ==========
    class LSTMCell {
        constructor(inputSize, hiddenSize, activation) {
            this.inputSize = inputSize;
            this.hiddenSize = hiddenSize;
            this.activation = activation;
            
            const scale = Math.sqrt(2.0 / (inputSize + hiddenSize));
            this.Wf = this.randomMatrix(hiddenSize, inputSize + hiddenSize, scale);
            this.Wi = this.randomMatrix(hiddenSize, inputSize + hiddenSize, scale);
            this.Wc = this.randomMatrix(hiddenSize, inputSize + hiddenSize, scale);
            this.Wo = this.randomMatrix(hiddenSize, inputSize + hiddenSize, scale);
            
            this.bf = new Array(hiddenSize).fill(1);
            this.bi = new Array(hiddenSize).fill(0);
            this.bc = new Array(hiddenSize).fill(0);
            this.bo = new Array(hiddenSize).fill(0);
            
            this.dWf = this.zeroMatrix(hiddenSize, inputSize + hiddenSize);
            this.dWi = this.zeroMatrix(hiddenSize, inputSize + hiddenSize);
            this.dWc = this.zeroMatrix(hiddenSize, inputSize + hiddenSize);
            this.dWo = this.zeroMatrix(hiddenSize, inputSize + hiddenSize);
            this.dbf = new Array(hiddenSize).fill(0);
            this.dbi = new Array(hiddenSize).fill(0);
            this.dbc = new Array(hiddenSize).fill(0);
            this.dbo = new Array(hiddenSize).fill(0);
        }

        randomMatrix(rows, cols, scale) {
            return Array.from({length: rows}, () => 
                Array.from({length: cols}, () => (Math.random() - 0.5) * 2 * scale)
            );
        }

        zeroMatrix(rows, cols) {
            return Array.from({length: rows}, () => new Array(cols).fill(0));
        }

        forward(input, prevH, prevC) {
            prevC = prevC || new Array(this.hiddenSize).fill(0);
            const concat = [...input, ...prevH];
            const sigmoid = Activations.sigmoid.fn;
            const tanhFn = Activations.tanh.fn;
            
            const f = [], i = [], cTilde = [], o = [];
            const c = [], h = [];
            
            for (let k = 0; k < this.hiddenSize; k++) {
                let sumF = this.bf[k], sumI = this.bi[k], sumC = this.bc[k], sumO = this.bo[k];
                for (let j = 0; j < concat.length; j++) {
                    sumF += this.Wf[k][j] * concat[j];
                    sumI += this.Wi[k][j] * concat[j];
                    sumC += this.Wc[k][j] * concat[j];
                    sumO += this.Wo[k][j] * concat[j];
                }
                f[k] = sigmoid(sumF);
                i[k] = sigmoid(sumI);
                cTilde[k] = tanhFn(sumC);
                o[k] = sigmoid(sumO);
                c[k] = f[k] * prevC[k] + i[k] * cTilde[k];
                h[k] = o[k] * tanhFn(c[k]);
            }
            
            return { h, c, f, i, cTilde, o, prevH: prevH.slice(), prevC: prevC.slice(), 
                     concat: concat.slice(), input: input.slice(), tanhC: c.map(tanhFn) };
        }

        backward(dh, dc, cache, clipVal) {
            const { h, c, f, i, cTilde, o, prevH, prevC, concat, tanhC } = cache;
            const sigmoidDfn = Activations.sigmoid.dfn;
            const tanhDfn = Activations.tanh.dfn;
            
            const dO = [], dC = [], dF = [], dI = [], dCTilde = [];
            const dcNext = new Array(this.hiddenSize).fill(0);
            
            for (let k = 0; k < this.hiddenSize; k++) {
                dO[k] = clipGradient(dh[k] * tanhC[k] * sigmoidDfn(o[k]), clipVal);
                dC[k] = clipGradient(dh[k] * o[k] * tanhDfn(tanhC[k]) + dc[k], clipVal);
                dF[k] = clipGradient(dC[k] * prevC[k] * sigmoidDfn(f[k]), clipVal);
                dI[k] = clipGradient(dC[k] * cTilde[k] * sigmoidDfn(i[k]), clipVal);
                dCTilde[k] = clipGradient(dC[k] * i[k] * tanhDfn(cTilde[k]), clipVal);
                dcNext[k] = dC[k] * f[k];
            }

            const dInput = new Array(this.inputSize).fill(0);
            const dPrevH = new Array(this.hiddenSize).fill(0);

            for (let k = 0; k < this.hiddenSize; k++) {
                for (let j = 0; j < concat.length; j++) {
                    this.dWf[k][j] += dF[k] * concat[j];
                    this.dWi[k][j] += dI[k] * concat[j];
                    this.dWc[k][j] += dCTilde[k] * concat[j];
                    this.dWo[k][j] += dO[k] * concat[j];
                    
                    const grad = this.Wf[k][j] * dF[k] + this.Wi[k][j] * dI[k] + 
                                 this.Wc[k][j] * dCTilde[k] + this.Wo[k][j] * dO[k];
                    if (j < this.inputSize) dInput[j] += grad;
                    else dPrevH[j - this.inputSize] += grad;
                }
                this.dbf[k] += dF[k];
                this.dbi[k] += dI[k];
                this.dbc[k] += dCTilde[k];
                this.dbo[k] += dO[k];
            }
            
            return { dInput, dPrevH, dPrevC: dcNext };
        }

        applyGradients(lr, clipVal) {
            const apply = (W, dW) => {
                for (let i = 0; i < W.length; i++) {
                    for (let j = 0; j < W[i].length; j++) {
                        W[i][j] -= lr * clipGradient(dW[i][j], clipVal);
                        dW[i][j] = 0;
                    }
                }
            };
            apply(this.Wf, this.dWf); apply(this.Wi, this.dWi);
            apply(this.Wc, this.dWc); apply(this.Wo, this.dWo);
            
            for (let k = 0; k < this.hiddenSize; k++) {
                this.bf[k] -= lr * clipGradient(this.dbf[k], clipVal); this.dbf[k] = 0;
                this.bi[k] -= lr * clipGradient(this.dbi[k], clipVal); this.dbi[k] = 0;
                this.bc[k] -= lr * clipGradient(this.dbc[k], clipVal); this.dbc[k] = 0;
                this.bo[k] -= lr * clipGradient(this.dbo[k], clipVal); this.dbo[k] = 0;
            }
        }

        resetGradients() {
            const n = this.inputSize + this.hiddenSize;
            this.dWf = this.zeroMatrix(this.hiddenSize, n);
            this.dWi = this.zeroMatrix(this.hiddenSize, n);
            this.dWc = this.zeroMatrix(this.hiddenSize, n);
            this.dWo = this.zeroMatrix(this.hiddenSize, n);
            this.dbf = new Array(this.hiddenSize).fill(0);
            this.dbi = new Array(this.hiddenSize).fill(0);
            this.dbc = new Array(this.hiddenSize).fill(0);
            this.dbo = new Array(this.hiddenSize).fill(0);
        }

        getHiddenSize() { return this.hiddenSize; }

        toJSON() {
            return { type: 'lstm', inputSize: this.inputSize, hiddenSize: this.hiddenSize,
                     activation: this.activation,
                     Wf: this.Wf, Wi: this.Wi, Wc: this.Wc, Wo: this.Wo,
                     bf: this.bf, bi: this.bi, bc: this.bc, bo: this.bo };
        }

        static fromJSON(json) {
             // Create instance with dummy values, then override with loaded weights
             const cell = new LSTMCell(json.inputSize || 1, json.hiddenSize || 1, json.activation || 'tanh');
             if (json.Wf) cell.Wf = json.Wf;
             if (json.Wi) cell.Wi = json.Wi;
             if (json.Wc) cell.Wc = json.Wc;
             if (json.Wo) cell.Wo = json.Wo;
             if (json.Bf) cell.bf = json.Bf;
             if (json.Bi) cell.bi = json.Bi;
             if (json.Bc) cell.bc = json.Bc;
             if (json.Bo) cell.bo = json.Bo;
             return cell;
         }
    }

    // ========== GRU Cell ==========
    class GRUCell {
        constructor(inputSize, hiddenSize, activation) {
            this.inputSize = inputSize;
            this.hiddenSize = hiddenSize;
            this.activation = activation;
            
            const scale = Math.sqrt(2.0 / (inputSize + hiddenSize));
            this.Wz = this.randomMatrix(hiddenSize, inputSize + hiddenSize, scale);
            this.Wr = this.randomMatrix(hiddenSize, inputSize + hiddenSize, scale);
            this.Wh = this.randomMatrix(hiddenSize, inputSize + hiddenSize, scale);
            
            this.bz = new Array(hiddenSize).fill(0);
            this.br = new Array(hiddenSize).fill(0);
            this.bh = new Array(hiddenSize).fill(0);
            
            this.dWz = this.zeroMatrix(hiddenSize, inputSize + hiddenSize);
            this.dWr = this.zeroMatrix(hiddenSize, inputSize + hiddenSize);
            this.dWh = this.zeroMatrix(hiddenSize, inputSize + hiddenSize);
            this.dbz = new Array(hiddenSize).fill(0);
            this.dbr = new Array(hiddenSize).fill(0);
            this.dbh = new Array(hiddenSize).fill(0);
        }

        randomMatrix(rows, cols, scale) {
            return Array.from({length: rows}, () => 
                Array.from({length: cols}, () => (Math.random() - 0.5) * 2 * scale)
            );
        }

        zeroMatrix(rows, cols) {
            return Array.from({length: rows}, () => new Array(cols).fill(0));
        }

        forward(input, prevH) {
            const concat = [...input, ...prevH];
            const sigmoid = Activations.sigmoid.fn;
            const tanhFn = Activations.tanh.fn;
            
            const z = [], r = [], hTilde = [], h = [];
            
            for (let k = 0; k < this.hiddenSize; k++) {
                let sumZ = this.bz[k], sumR = this.br[k];
                for (let j = 0; j < concat.length; j++) {
                    sumZ += this.Wz[k][j] * concat[j];
                    sumR += this.Wr[k][j] * concat[j];
                }
                z[k] = sigmoid(sumZ);
                r[k] = sigmoid(sumR);
            }
            
            const rh = prevH.map((h, i) => r[i] * h);
            const concatR = [...input, ...rh];
            
            for (let k = 0; k < this.hiddenSize; k++) {
                let sumH = this.bh[k];
                for (let j = 0; j < concatR.length; j++) {
                    sumH += this.Wh[k][j] * concatR[j];
                }
                hTilde[k] = tanhFn(sumH);
                h[k] = (1 - z[k]) * prevH[k] + z[k] * hTilde[k];
            }
            
            return { h, z, r, hTilde, prevH: prevH.slice(), concat: concat.slice(), 
                     concatR: concatR.slice(), input: input.slice() };
        }

        backward(dh, cache, clipVal) {
            const { h, z, r, hTilde, prevH, concat, concatR } = cache;
            const sigmoidDfn = Activations.sigmoid.dfn;
            const tanhDfn = Activations.tanh.dfn;
            
            const dZ = [], dR = [], dHTilde = [];
            const dPrevH = new Array(this.hiddenSize).fill(0);
            const dInput = new Array(this.inputSize).fill(0);

            for (let k = 0; k < this.hiddenSize; k++) {
                dHTilde[k] = clipGradient(dh[k] * z[k] * tanhDfn(hTilde[k]), clipVal);
                dZ[k] = clipGradient(dh[k] * (hTilde[k] - prevH[k]) * sigmoidDfn(z[k]), clipVal);
                dPrevH[k] = dh[k] * (1 - z[k]);
            }

            for (let k = 0; k < this.hiddenSize; k++) {
                for (let j = 0; j < concatR.length; j++) {
                    this.dWh[k][j] += dHTilde[k] * concatR[j];
                    const grad = this.Wh[k][j] * dHTilde[k];
                    if (j < this.inputSize) dInput[j] += grad;
                    else {
                        const hidIdx = j - this.inputSize;
                        dR[hidIdx] = (dR[hidIdx] || 0) + grad * prevH[hidIdx];
                        dPrevH[hidIdx] += grad * r[hidIdx];
                    }
                }
                this.dbh[k] += dHTilde[k];
            }

            for (let k = 0; k < this.hiddenSize; k++) {
                dR[k] = clipGradient((dR[k] || 0) * sigmoidDfn(r[k]), clipVal);
                for (let j = 0; j < concat.length; j++) {
                    this.dWz[k][j] += dZ[k] * concat[j];
                    this.dWr[k][j] += dR[k] * concat[j];
                    const grad = this.Wz[k][j] * dZ[k] + this.Wr[k][j] * dR[k];
                    if (j < this.inputSize) dInput[j] += grad;
                    else dPrevH[j - this.inputSize] += grad;
                }
                this.dbz[k] += dZ[k];
                this.dbr[k] += dR[k];
            }
            
            return { dInput, dPrevH };
        }

        applyGradients(lr, clipVal) {
            const apply = (W, dW) => {
                for (let i = 0; i < W.length; i++) {
                    for (let j = 0; j < W[i].length; j++) {
                        W[i][j] -= lr * clipGradient(dW[i][j], clipVal);
                        dW[i][j] = 0;
                    }
                }
            };
            apply(this.Wz, this.dWz); apply(this.Wr, this.dWr); apply(this.Wh, this.dWh);
            
            for (let k = 0; k < this.hiddenSize; k++) {
                this.bz[k] -= lr * clipGradient(this.dbz[k], clipVal); this.dbz[k] = 0;
                this.br[k] -= lr * clipGradient(this.dbr[k], clipVal); this.dbr[k] = 0;
                this.bh[k] -= lr * clipGradient(this.dbh[k], clipVal); this.dbh[k] = 0;
            }
        }

        resetGradients() {
            const n = this.inputSize + this.hiddenSize;
            this.dWz = this.zeroMatrix(this.hiddenSize, n);
            this.dWr = this.zeroMatrix(this.hiddenSize, n);
            this.dWh = this.zeroMatrix(this.hiddenSize, n);
            this.dbz = new Array(this.hiddenSize).fill(0);
            this.dbr = new Array(this.hiddenSize).fill(0);
            this.dbh = new Array(this.hiddenSize).fill(0);
        }

        getHiddenSize() { return this.hiddenSize; }

        toJSON() {
            return { type: 'gru', inputSize: this.inputSize, hiddenSize: this.hiddenSize,
                     activation: this.activation,
                     Wz: this.Wz, Wr: this.Wr, Wh: this.Wh,
                     bz: this.bz, br: this.br, bh: this.bh };
        }

        static fromJSON(json) {
            const cell = new GRUCell(json.inputSize || 1, json.hiddenSize || 1, json.activation || 'tanh');
            if (json.Wz) cell.Wz = json.Wz;
            if (json.Wr) cell.Wr = json.Wr;
            if (json.Wh) cell.Wh = json.Wh;
            if (json.Bz) cell.bz = json.Bz;
            if (json.Br) cell.br = json.Br;
            if (json.Bh) cell.bh = json.Bh;
            return cell;
        }
    }

    // ========== Output Layer ==========
    class OutputLayer {
        constructor(inputSize, outputSize, activation) {
            this.inputSize = inputSize;
            this.outputSize = outputSize;
            this.activation = activation;
            
            const scale = Math.sqrt(2.0 / inputSize);
            this.W = Array.from({length: outputSize}, () => 
                Array.from({length: inputSize}, () => (Math.random() - 0.5) * 2 * scale)
            );
            this.b = new Array(outputSize).fill(0);
            this.dW = Array.from({length: outputSize}, () => new Array(inputSize).fill(0));
            this.db = new Array(outputSize).fill(0);
        }

        forward(input) {
            const pre = new Array(this.outputSize);
            for (let i = 0; i < this.outputSize; i++) {
                let sum = this.b[i];
                for (let j = 0; j < this.inputSize; j++) sum += this.W[i][j] * input[j];
                pre[i] = sum;
            }
            
            let out;
            if (this.activation === 'softmax') {
                out = applySoftmax(pre);
            } else {
                const act = Activations[this.activation] || Activations.linear;
                out = pre.map(v => act.fn(v));
            }
            return { output: out, pre, input: input.slice() };
        }

        backward(dOut, cache, clipVal) {
            const { output, pre, input } = cache;
            const dInput = new Array(this.inputSize).fill(0);
            
            let dPre;
            if (this.activation === 'softmax') {
                dPre = dOut.slice();
            } else {
                const act = Activations[this.activation] || Activations.linear;
                dPre = dOut.map((d, i) => clipGradient(d * act.dfn(output[i]), clipVal));
            }

            for (let i = 0; i < this.outputSize; i++) {
                for (let j = 0; j < this.inputSize; j++) {
                    this.dW[i][j] += dPre[i] * input[j];
                    dInput[j] += this.W[i][j] * dPre[i];
                }
                this.db[i] += dPre[i];
            }
            return dInput;
        }

        applyGradients(lr, clipVal) {
            for (let i = 0; i < this.outputSize; i++) {
                for (let j = 0; j < this.inputSize; j++) {
                    this.W[i][j] -= lr * clipGradient(this.dW[i][j], clipVal);
                    this.dW[i][j] = 0;
                }
                this.b[i] -= lr * clipGradient(this.db[i], clipVal);
                this.db[i] = 0;
            }
        }

        resetGradients() {
            this.dW = Array.from({length: this.outputSize}, () => new Array(this.inputSize).fill(0));
            this.db = new Array(this.outputSize).fill(0);
        }

        toJSON() {
            return { inputSize: this.inputSize, outputSize: this.outputSize,
                     activation: this.activation, W: this.W, b: this.b };
        }

        static fromJSON(json) {
            const layer = new OutputLayer(json.inputSize || 1, json.outputSize || 1, json.activation || 'linear');
            if (json.W) layer.W = json.W;
            if (json.B) layer.b = json.B;
            return layer;
        }
    }

    // ========== Main RNN Network with BPTT ==========
    class AdvancedRNN {
        constructor(config) {
            this.inputSize = config.inputSize;
            this.outputSize = config.outputSize;
            this.hiddenSizes = config.hiddenSizes;
            this.cellType = config.cellType || 'lstm';
            this.activation = config.activation || 'tanh';
            this.outputActivation = config.outputActivation || 'linear';
            this.lossFunction = config.lossFunction || 'mse';
            this.learningRate = config.learningRate || 0.01;
            this.gradientClip = config.gradientClip || 5.0;
            this.bpttSteps = config.bpttSteps || 0;
            
            this.cells = [];
            let prevSize = this.inputSize;
            for (const hs of this.hiddenSizes) {
                let cell;
                if (this.cellType === 'lstm') cell = new LSTMCell(prevSize, hs, this.activation);
                else if (this.cellType === 'gru') cell = new GRUCell(prevSize, hs, this.activation);
                else cell = new SimpleRNNCell(prevSize, hs, this.activation);
                this.cells.push(cell);
                prevSize = hs;
            }
            
            this.outputLayer = new OutputLayer(prevSize, this.outputSize, this.outputActivation);
        }

        initHiddenState() {
            return this.cells.map(cell => ({
                h: new Array(cell.getHiddenSize()).fill(0),
                c: new Array(cell.getHiddenSize()).fill(0)
            }));
        }

        forwardStep(input, states) {
            const caches = [];
            let x = input;
            const newStates = [];
            
            for (let i = 0; i < this.cells.length; i++) {
                const cell = this.cells[i];
                let cache;
                if (cell instanceof LSTMCell) {
                    cache = cell.forward(x, states[i].h, states[i].c);
                    newStates.push({ h: cache.h, c: cache.c });
                } else {
                    cache = cell.forward(x, states[i].h);
                    newStates.push({ h: cache.h, c: states[i].c });
                }
                caches.push(cache);
                x = cache.h;
            }
            
            const outCache = this.outputLayer.forward(x);
            return { output: outCache.output, caches, outCache, states: newStates };
        }

        forwardSequence(inputs) {
            let states = this.initHiddenState();
            const outputs = [];
            const allCaches = [];
            const allStates = [states];
            
            for (const input of inputs) {
                const result = this.forwardStep(input, states);
                outputs.push(result.output);
                allCaches.push({ cellCaches: result.caches, outCache: result.outCache });
                states = result.states;
                allStates.push(states);
            }
            
            return { outputs, allCaches, allStates };
        }

        backwardSequence(targets, allCaches, allStates) {
            const T = targets.length;
            const lossFn = LossFunctions[this.lossFunction];
            let totalLoss = 0;
            
            let dStates = this.cells.map(cell => ({
                dh: new Array(cell.getHiddenSize()).fill(0),
                dc: new Array(cell.getHiddenSize()).fill(0)
            }));
            
            const bpttLimit = this.bpttSteps > 0 ? this.bpttSteps : T;
            
            for (let t = T - 1; t >= Math.max(0, T - bpttLimit); t--) {
                const { cellCaches, outCache } = allCaches[t];
                const target = targets[t];
                
                totalLoss += lossFn.loss(outCache.output, target);
                const dOut = lossFn.gradient(outCache.output, target);
                
                let dh = this.outputLayer.backward(dOut, outCache, this.gradientClip);
                
                for (let i = this.cells.length - 1; i >= 0; i--) {
                    const cell = this.cells[i];
                    const cache = cellCaches[i];
                    cache.h = allStates[t + 1][i].h;
                    
                    const dhTotal = dh.map((d, j) => d + dStates[i].dh[j]);
                    
                    let result;
                    if (cell instanceof LSTMCell) {
                        result = cell.backward(dhTotal, dStates[i].dc, cache, this.gradientClip);
                        dStates[i].dc = result.dPrevC;
                    } else {
                        result = cell.backward(dhTotal, cache, this.gradientClip);
                    }
                    
                    dStates[i].dh = result.dPrevH;
                    dh = result.dInput;
                }
            }
            
            return totalLoss / T;
        }

        trainSequence(inputs, targets) {
            this.resetGradients();
            const { outputs, allCaches, allStates } = this.forwardSequence(inputs);
            const loss = this.backwardSequence(targets, allCaches, allStates);
            this.applyGradients();
            return loss;
        }

        trainBatch(batchInputs, batchTargets) {
            this.resetGradients();
            let totalLoss = 0;
            
            for (let b = 0; b < batchInputs.length; b++) {
                const { outputs, allCaches, allStates } = this.forwardSequence(batchInputs[b]);
                totalLoss += this.backwardSequence(batchTargets[b], allCaches, allStates);
            }
            
            const batchSize = batchInputs.length;
            for (const cell of this.cells) {
                if (cell instanceof LSTMCell) {
                    this.scaleGradients(cell.dWf, batchSize);
                    this.scaleGradients(cell.dWi, batchSize);
                    this.scaleGradients(cell.dWc, batchSize);
                    this.scaleGradients(cell.dWo, batchSize);
                } else if (cell instanceof GRUCell) {
                    this.scaleGradients(cell.dWz, batchSize);
                    this.scaleGradients(cell.dWr, batchSize);
                    this.scaleGradients(cell.dWh, batchSize);
                } else {
                    this.scaleGradients(cell.dWih, batchSize);
                    this.scaleGradients(cell.dWhh, batchSize);
                }
            }
            this.scaleGradients(this.outputLayer.dW, batchSize);
            
            this.applyGradients();
            return totalLoss / batchSize;
        }

        scaleGradients(matrix, scale) {
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[i].length; j++) {
                    matrix[i][j] /= scale;
                }
            }
        }

        predict(inputs) {
            const { outputs } = this.forwardSequence(inputs);
            return outputs;
        }

        computeLoss(inputs, targets) {
            const outputs = this.predict(inputs);
            const lossFn = LossFunctions[this.lossFunction];
            let total = 0;
            for (let t = 0; t < outputs.length; t++) {
                total += lossFn.loss(outputs[t], targets[t]);
            }
            return total / outputs.length;
        }

        resetGradients() {
            for (const cell of this.cells) cell.resetGradients();
            this.outputLayer.resetGradients();
        }

        applyGradients() {
            for (const cell of this.cells) cell.applyGradients(this.learningRate, this.gradientClip);
            this.outputLayer.applyGradients(this.learningRate, this.gradientClip);
        }

        toJSON() {
            return JSON.stringify({
                inputSize: this.inputSize,
                outputSize: this.outputSize,
                hiddenSizes: this.hiddenSizes,
                cellType: this.cellType,
                activation: this.activation,
                outputActivation: this.outputActivation,
                lossFunction: this.lossFunction,
                learningRate: this.learningRate,
                gradientClip: this.gradientClip,
                bpttSteps: this.bpttSteps,
                cells: this.cells.map(c => c.toJSON()),
                outputLayer: this.outputLayer.toJSON()
            });
        }

        static fromJSON(jsonStr) {
            const obj = JSON.parse(jsonStr);
            
            // Convert snake_case from Pascal to camelCase for constructor
            const config = {
                inputSize: obj.input_size,
                outputSize: obj.output_size,
                hiddenSizes: obj.hidden_sizes,
                cellType: obj.cell_type,
                activation: obj.activation,
                outputActivation: obj.output_activation,
                lossFunction: obj.loss_type === 'mse' ? 'mse' : 'crossentropy',
                learningRate: obj.learning_rate,
                gradientClip: obj.gradient_clip,
                bpttSteps: obj.bptt_steps
            };
            
            const rnn = new AdvancedRNN(config);
            
            // Load weights if present
            if (obj.cells && obj.cells.length > 0) {
                for (let i = 0; i < obj.cells.length; i++) {
                    const cellData = obj.cells[i];
                    if (obj.cell_type === 'lstm') rnn.cells[i] = LSTMCell.fromJSON(cellData);
                    else if (obj.cell_type === 'gru') rnn.cells[i] = GRUCell.fromJSON(cellData);
                    else rnn.cells[i] = SimpleRNNCell.fromJSON(cellData);
                }
            }
            if (obj.output_layer) {
                rnn.outputLayer = OutputLayer.fromJSON(obj.output_layer);
            }
            return rnn;
        }
    }

    // ========== Global State ==========
    let rnn = null;
    let inputs = [];
    let targets = [];
    let trainInputs = [], trainTargets = [];
    let valInputs = [], valTargets = [];
    let trainingLoss = [], validationLoss = [];
    let stopFlag = false;

    // ========== UI Functions ==========
    function createNetwork() {
        const config = {
            inputSize: parseInt(document.getElementById("inputSize").value),
            hiddenSizes: document.getElementById("hiddenSizes").value.split(",").map(s => parseInt(s.trim())).filter(n => !isNaN(n)),
            outputSize: parseInt(document.getElementById("outputSize").value),
            learningRate: parseFloat(document.getElementById("learningRate").value),
            cellType: document.getElementById("cellType").value,
            activation: document.getElementById("activation").value,
            outputActivation: document.getElementById("outputActivation").value,
            lossFunction: document.getElementById("lossFunction").value,
            gradientClip: parseFloat(document.getElementById("gradientClip").value),
            bpttSteps: parseInt(document.getElementById("bpttSteps").value)
        };
        
        rnn = new AdvancedRNN(config);
        trainingLoss = [];
        validationLoss = [];
        document.getElementById("networkStatus").textContent = 
            `Created ${config.cellType.toUpperCase()}: In=${config.inputSize}, Hidden=[${config.hiddenSizes}], Out=${config.outputSize}`;
    }

    function parseCSV(text, inputSize, outputSize) {
        const lines = text.trim().split("\n");
        const seqInputs = [], seqTargets = [];
        for (const line of lines) {
            if (line.trim() === "") continue;
            const arr = line.trim().split(",").map(Number);
            const input = arr.slice(0, inputSize);
            let target = arr.slice(inputSize, inputSize + outputSize);
            if (target.length < outputSize) {
                for (let j = target.length; j < outputSize; j++) target.push(input[j % input.length] || 0);
            }
            seqInputs.push(input);
            seqTargets.push(target);
        }
        return { inputs: seqInputs, targets: seqTargets };
    }

    function splitData(inputs, targets, valSplit) {
        const n = inputs.length;
        const valCount = Math.floor(n * valSplit);
        const trainCount = n - valCount;
        
        const indices = Array.from({length: n}, (_, i) => i);
        for (let i = n - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [indices[i], indices[j]] = [indices[j], indices[i]];
        }
        
        trainInputs = indices.slice(0, trainCount).map(i => inputs[i]);
        trainTargets = indices.slice(0, trainCount).map(i => targets[i]);
        valInputs = indices.slice(trainCount).map(i => inputs[i]);
        valTargets = indices.slice(trainCount).map(i => targets[i]);
    }

    function loadCSV() {
        const file = document.getElementById('csvFile').files[0];
        if (!file) {
            document.getElementById('dataStatus').textContent = "No file selected.";
            return;
        }
        const reader = new FileReader();
        reader.onload = function(e) {
            const inputSize = parseInt(document.getElementById("inputSize").value);
            const outputSize = parseInt(document.getElementById("outputSize").value);
            const result = parseCSV(e.target.result, inputSize, outputSize);
            inputs = result.inputs;
            targets = result.targets;
            const valSplit = parseFloat(document.getElementById("validationSplit").value);
            splitData(inputs, targets, valSplit);
            document.getElementById('dataStatus').textContent = 
                `Loaded ${inputs.length} samples (Train: ${trainInputs.length}, Val: ${valInputs.length})`;
        };
        reader.readAsText(file);
    }

    function loadCSVText() {
        const text = document.getElementById('csvPaste').value;
        if (!text.trim()) {
            document.getElementById('dataStatus').textContent = "No data pasted.";
            return;
        }
        const inputSize = parseInt(document.getElementById("inputSize").value);
        const outputSize = parseInt(document.getElementById("outputSize").value);
        const result = parseCSV(text, inputSize, outputSize);
        inputs = result.inputs;
        targets = result.targets;
        const valSplit = parseFloat(document.getElementById("validationSplit").value);
        splitData(inputs, targets, valSplit);
        document.getElementById('dataStatus').textContent = 
            `Loaded ${inputs.length} samples (Train: ${trainInputs.length}, Val: ${valInputs.length})`;
    }

    function saveNetwork() {
        if (!rnn) return alert("Create an RNN first.");
        const blob = new Blob([rnn.toJSON()], {type: "application/json"});
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "rnn-network.json";
        a.click();
        document.getElementById('modelStatus').textContent = "Network saved.";
    }

    function loadNetwork() {
        document.getElementById('modelFile').onchange = function(evt) {
            const file = evt.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    rnn = AdvancedRNN.fromJSON(e.target.result);
                    if (!rnn) {
                        document.getElementById('modelStatus').textContent = "Error: Failed to parse model";
                        console.error("fromJSON returned null");
                        return;
                    }
                    document.getElementById('modelStatus').textContent = "Network loaded!";
                    document.getElementById("cellType").value = rnn.cellType;
                    document.getElementById("activation").value = rnn.activation;
                    document.getElementById("outputActivation").value = rnn.outputActivation;
                    document.getElementById("lossFunction").value = rnn.lossFunction;
                    console.log("Model loaded successfully", rnn);
                } catch (err) {
                    document.getElementById('modelStatus').textContent = "Error: " + err.message;
                    console.error("Load error:", err);
                }
            };
            reader.readAsText(file);
        };
        document.getElementById('modelFile').click();
    }

    function stopTraining() {
        stopFlag = true;
    }

    async function trainNetwork() {
        if (!rnn) return alert("Create an RNN first.");
        if (!trainInputs.length) return alert("Load data first.");
        
        stopFlag = false;
        const epochs = parseInt(document.getElementById("epochs").value);
        const batchSize = parseInt(document.getElementById("batchSize").value);
        const logInterval = parseInt(document.getElementById("logInterval").value);
        
        const logDiv = document.getElementById("lossLog");
        logDiv.innerHTML = "<strong>Training...</strong><br>";
        trainingLoss = [];
        validationLoss = [];

        for (let epoch = 1; epoch <= epochs; epoch++) {
            if (stopFlag) {
                logDiv.innerHTML += `<br><em>Training stopped at epoch ${epoch}</em>`;
                break;
            }
            
            let epochLoss = 0;
            if (batchSize === 1) {
                for (let i = 0; i < trainInputs.length; i++) {
                    epochLoss += rnn.trainSequence([trainInputs[i]], [trainTargets[i]]);
                }
                epochLoss /= trainInputs.length;
            } else {
                const batches = [];
                for (let i = 0; i < trainInputs.length; i += batchSize) {
                    batches.push({
                        inputs: trainInputs.slice(i, i + batchSize).map(x => [x]),
                        targets: trainTargets.slice(i, i + batchSize).map(x => [x])
                    });
                }
                for (const batch of batches) {
                    epochLoss += rnn.trainBatch(batch.inputs, batch.targets);
                }
                epochLoss /= batches.length;
            }
            
            trainingLoss.push(epochLoss);
            
            let valLoss = 0;
            if (valInputs.length > 0) {
                for (let i = 0; i < valInputs.length; i++) {
                    valLoss += rnn.computeLoss([valInputs[i]], [valTargets[i]]);
                }
                valLoss /= valInputs.length;
            }
            validationLoss.push(valLoss);

            if (epoch % logInterval === 0 || epoch === epochs) {
                const valStr = valInputs.length > 0 ? `, Val Loss: ${valLoss.toFixed(6)}` : '';
                logDiv.innerHTML += `Epoch ${epoch}: Train Loss: ${epochLoss.toFixed(6)}${valStr}<br>`;
                logDiv.scrollTop = logDiv.scrollHeight;
                drawLossChart();
                await new Promise(r => setTimeout(r, 0));
            }
        }
        
        document.getElementById("trainStatus").textContent = "Training complete!";
        drawLossChart();
    }

    function drawLossChart() {
        const canvas = document.getElementById("lossChart");
        const ctx = canvas.getContext("2d");
        const w = canvas.width = canvas.offsetWidth;
        const h = canvas.height = canvas.offsetHeight;
        
        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = "#fafafa";
        ctx.fillRect(0, 0, w, h);
        
        if (trainingLoss.length < 2) return;
        
        const allLoss = [...trainingLoss, ...validationLoss.filter(v => v > 0)];
        const maxLoss = Math.max(...allLoss) * 1.1;
        const minLoss = Math.min(...allLoss) * 0.9;
        
        const padL = 50, padR = 20, padT = 20, padB = 30;
        const plotW = w - padL - padR;
        const plotH = h - padT - padB;
        
        ctx.strokeStyle = "#ddd";
        ctx.beginPath();
        for (let i = 0; i <= 4; i++) {
            const y = padT + (plotH * i / 4);
            ctx.moveTo(padL, y);
            ctx.lineTo(w - padR, y);
        }
        ctx.stroke();
        
        ctx.fillStyle = "#333";
        ctx.font = "10px Arial";
        for (let i = 0; i <= 4; i++) {
            const val = maxLoss - (maxLoss - minLoss) * i / 4;
            const y = padT + (plotH * i / 4);
            ctx.fillText(val.toFixed(4), 5, y + 3);
        }
        
        const drawLine = (data, color) => {
            if (data.length < 2) return;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < data.length; i++) {
                const x = padL + (i / (data.length - 1)) * plotW;
                const y = padT + plotH - ((data[i] - minLoss) / (maxLoss - minLoss)) * plotH;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        };
        
        drawLine(trainingLoss, "#2196F3");
        if (validationLoss.some(v => v > 0)) drawLine(validationLoss, "#FF5722");
        
        ctx.fillStyle = "#2196F3";
        ctx.fillRect(w - 100, 5, 10, 10);
        ctx.fillStyle = "#333";
        ctx.fillText("Train", w - 85, 13);
        
        if (validationLoss.some(v => v > 0)) {
            ctx.fillStyle = "#FF5722";
            ctx.fillRect(w - 100, 20, 10, 10);
            ctx.fillStyle = "#333";
            ctx.fillText("Val", w - 85, 28);
        }
    }

    function parseSequenceInput(str) {
        return str.trim().split(/[\n;]/).map(line =>
            line.trim().split(",").map(v => parseFloat(v.trim())).filter(x => !isNaN(x))
        ).filter(arr => arr.length > 0);
    }

    function predictSequence() {
        if (!rnn) {
            document.getElementById("predictOutput").textContent = "Create RNN first!";
            return;
        }
        const seqStr = document.getElementById("predictSeq").value;
        const seq = parseSequenceInput(seqStr);
        const preds = rnn.predict(seq);

        let out = "<pre>";
        out += "t | Inputs | Predictions\n";
        out += "-".repeat(50) + "\n";
        for (let t = 0; t < seq.length; t++) {
            out += t + " | " + seq[t].map(x => x.toFixed(4)).join(" ") + " | " + preds[t].map(x => x.toFixed(4)).join(" ") + "\n";
        }
        out += "</pre>";
        document.getElementById("predictOutput").innerHTML = out;
    }
    </script>
</body>
</html>
